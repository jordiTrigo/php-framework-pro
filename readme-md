# The Request -> Response Cycle

## The Front Controller

The `Front Controller` is a software design pattern which provides just a single entrypoint to a web application.

This pattern is used by all of the PHP frameworks that you can think of and provides many benefits, the main ones being:

- Centralized control
- System maintainability
- Configurability


We will be using a simple `Docker` configuration but please use whatever works for you if you have a preferred setup.

What I will add is that, when I started working on this, I hadn't already worked out what tech was going to be involved so I started out with `Docker` just in case I needed any installable tech or non-common PHP extensions.

As it turned out, I kept everything really simple and even the DB is just an sqlite file. SO...if you have PHP and Composer installed on your computer, it's totally possible to complete this course just with PHP's built-in server. Simply run this command and you're up and running:

```bash
php -S localhost:8000 public/index.php
```

If you do want to use the same setup as me, then just copy the `docker-compose.yaml` file, which is attached to the lesson, into your project root. You will need to have Docker Desktop installed. The command to get things running is:

`$ docker compose -f docker-compose.yaml up -d`

I won't be covering Docker in any more detail than that but you can learn more about it by enrolling in my Docker course for free here:
```
https://www.garyclarke.tech/p/learn-docker-and-php
```


## Autoloading

Before we start to create Http classes to represent request and response, let's dive into `Composer` in order to set up `autoloading`.

The folder structure will be important here because we are creating framework files and classes but also application files and classes (i.e. the kind of files that a framework user would create). I intend to keep these separate by having a src folder and a framework folder.

Because I am using docker, I execute these commands in my running app container by prefixing them with this: 
```bash
docker compose exec app
```

If you are just using Composer installed locally on your computer, just run the `Composer` commands as normal.

*Note* - I don't mention this in the recording but I also added the `/vendor` folder to the `.gitignore` file. 


### composer.json 

In the file `/php-framework-pro/composer.json` we map certain namespaces to certain folders:
1. `App\\` namespace maps the `src/` folder.
2. `AriadnaJordi\\Framework\\` namespace maps the `framework/` folder.

With that file:

```json
{
    "name": "ajt-30/php-framework-pro",
    "description": "A PHP framework tutorial project",
    "minimum-stability": "dev",
    "license": "MIT",
    "authors": [
        {
            "name": "AJT",
            "email": "ajt@gmail.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/",
            "AriadnaJordi\\Framework\\": "framework/"
        }
    },
    "require": {        
    }
}
```

We now execute in the terminal:

```bash
jordi@jordi-HP-Laptop-15s-fq1xxx:~/Dev/PHP/php-framework-pro$ docker compose exec app composer dump-autoload
Generating autoload files
Generated autoload files

jordi@jordi-HP-Laptop-15s-fq1xxx:~/Dev/PHP/php-framework-pro$ docker compose exec app composer require symfony/var-dumper
Using version 7.0.x-dev for symfony/var-dumper
./composer.json has been updated
Running composer update symfony/var-dumper
Loading composer repositories with package information
Updating dependencies
Lock file operations: 2 installs, 0 updates, 0 removals
  - Locking symfony/polyfill-mbstring (1.x-dev 42292d9)
  - Locking symfony/var-dumper (7.0.x-dev 3c833bc)
Writing lock file
Installing dependencies from lock file (including require-dev)
Package operations: 2 installs, 0 updates, 0 removals
  - Downloading symfony/polyfill-mbstring (1.x-dev 42292d9)
  - Downloading symfony/var-dumper (7.0.x-dev 3c833bc)
  - Installing symfony/polyfill-mbstring (1.x-dev 42292d9): Extracting archive
  - Installing symfony/var-dumper (7.0.x-dev 3c833bc): Extracting archive
Generating autoload files
2 packages you are using are looking for funding.
Use the `composer fund` command to find out more!
No security vulnerability advisories found
```

Now the file `/php-framework-pro/composer.json` converts into:

```json
{
    "name": "ajt-30/php-framework-pro",
    "description": "A PHP framework tutorial project",
    "minimum-stability": "dev",
    "license": "MIT",
    "authors": [
        {
            "name": "AJT",
            "email": "ajt@gmail.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/",
            "AriadnaJordi\\Framework\\": "framework/"
        }
    },
    "require": {
        "symfony/var-dumper": "7.0.x-dev"
    }
}
```

We modify the `require` key to `require-dev`:

```json
{
    "name": "ajt-30/php-framework-pro",
    "description": "A PHP framework tutorial project",
    "minimum-stability": "dev",
    "license": "MIT",
    "authors": [
        {
            "name": "AJT",
            "email": "ajt@gmail.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/",
            "AriadnaJordi\\Framework\\": "framework/"
        }
    },
    "require-dev": {
        "symfony/var-dumper": "7.0.x-dev"
    }
}
```

Now it has appeared a new folder called `/php-framework-pro/vendor/` and inside it we got the `autoload.php` file
which means we can start autoloading files and they'll autoloading from or using the namespaces `App\\` and the
folder location `src/` and the same for `AriadnaJordi\\Framework\\` and `framework/`

Now we go to our `/php-framework-pro/public/index.php` file and we add autoloading at the top:

```php
<?php declare(strict_types=1);

require_once dirname(__DIR__) . '/vendor/autoload.php';

// request received

// perform some logic

// send response (string of content)
echo 'Hello World';
```

Also as we have installed the `symfony/var-dumper` inside our docker container app, so now we can use the function `dd()` that stands for die and dump that it will kill the application and then dump out whatever variable(s) we pass it.

```php
<?php declare(strict_types=1);

require_once dirname(__DIR__) . '/vendor/autoload.php';


dd('Here!');

// request received

// perform some logic

// send response (string of content)
echo 'Hello World';
```


## Request Class

All PHP frameworks use objects to represent the incoming request. One of the greatest advantages of this is encapsulation: we can store all of the superglobal values as properties on our request object and those values will be preserved and protected from being tampered with unlike the superglobals which can have their values altered.

We will be able to use some of the properties on our request object in order to perform important operations such as routing the request to the correct handler (controller) etc.

The `Request` class which I create here is a superlight model based on the `Symfony Http Foundation request class`:
```
https://symfony.com/doc/current/components/http_foundation.html
```

We have created that request class in order to encapsulate the data available to us when the HTTP request is received by our application.


## Response Class

In the same way that we did with the request, let's also encapsulate the response data by creating a response class. There are 3 main pieces of data associated with a response and they are:

- Content
- Status (code)
- Headers

ie, all the information which gets send back with the HTTP response.

The content will always be a string (or null) so we can send it by echoing it from a `$response->send()` method.



## Http Kernel

We've now created both ends of the `request-response cycle` so, we've looked at the `Request` class and the `Response` class so now let's consider a class which is responsible for taking that `Request` and returning a `Response`.

For this we are going to create a `HTTP Kernel` class which is the heart of your application. It is used both for Laravel and Symfony to represent the core of the applicaton from a very high level. This class will be composed of the main components that we are going to need to complete the `request -> response cycle`. It's responsability is to receive a request and output a response and, this is handle by a sole method called `handle()`.

```php
$response = $kernel->handle($request);
```


# Routing

Now we have our HTTP essentials in place, that's our `Request` class, our `Response` class and our `Kernel` class. What we want to do now is to be able to have custom handling for different requests to different URIs. The way we can do that is with `routing`.

Once the `request` is received by our application, it is forwarded always to our public `index.php`, but now we need to `route` that `request` to a `handler` and we use the **path info or parts of the URI to determine what handler it should be forwarded to**.

``` 
/path  ===>  handler()
```

We do this by having pre-defined routes which pattern-match URI's. If a requested uri matches the pattern for a route, the request is then forwarded on to the correct handler for that route. For example, we have an user's URI and also a post's URI and we want to handle a request to a user's endpoint differently than we do a post's endpoint. So we **forward them to different handlers**.

```
/users  ===>  users-handler()

/posts  ===>  posts-handler()
```

A handler is simply a callable function which has custom handling for requests to URI's matching that particular route. It can be:

- A callback, a
- A function in the same file, or 
- An array containing an object and the name of a method on that object.

Usually we'll use regular expressions or `regex` to match the URI to an established route and to direct the `request` to the `handler` for a route.

```
URI: /users/55

matches...

Route: /users/{id:\d+}

forwards to...

Handler: user-handler($id)
```

## FastRoute Router

For our routing we are going to use a 3rd party package called `FastRoute` which uses regular expressions to match URI's to routes and their handlers.

You can find `FastRoute` here: https://github.com/nikic/FastRoute and we will install it using composer.

Using `FastRoute` you obtain a dispatcher object 

```php
$dispatcher = FastRoute\simpleDispatcher(function(FastRoute\RouteCollector $r) {
    $r->addRoute('GET', '/users', 'get_all_users_handler');
    // {id} must be a number (\d+)
    $r->addRoute('GET', '/user/{id:\d+}', 'get_user_handler');
    // The /{title} suffix is optional
    $r->addRoute('GET', '/articles/{id:\d+}[/{title}]', 'get_article_handler');
});
```

and basically you're adding a route like this

```php
$r->addRoute('GET', '/users', 'get_all_users_handler');
```

where we say what method, for example `GET` (so if I make a client request in the browser to a webpage, that is a `GET` request and if I submit a form that would be a `POST` request), then you provide the URI (`/users`) or patterns (`/user/{id:\d+}`)

Now we install the `FastRoute` package:

```bash
$ docker compose exec app composer require nikic/fast-route

Using version 2.0.x-dev for nikic/fast-route
./composer.json has been updated
Running composer update nikic/fast-route
Loading composer repositories with package information
Updating dependencies
Lock file operations: 1 install, 0 updates, 0 removals
  - Locking nikic/fast-route (dev-master 7a2713c)
Writing lock file
Installing dependencies from lock file (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Downloading nikic/fast-route (dev-master 7a2713c)
  - Installing nikic/fast-route (dev-master 7a2713c): Extracting archive
Generating autoload files
2 packages you are using are looking for funding.
Use the `composer fund` command to find out more!
No security vulnerability advisories found
```

Now if we check the `composer.json` file:

```json
{
    "name": "ajt-30/php-framework-pro",
    "description": "A PHP framework tutorial project",
    "minimum-stability": "dev",
    "license": "MIT",
    "authors": [
        {
            "name": "AJT",
            "email": "ajt@gmail.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/",
            "AriadnaJordi\\Framework\\": "framework/"
        }
    },
    "require-dev": {
        "symfony/var-dumper": "7.0.x-dev"
    },
    "require": {
        "nikic/fast-route": "2.0.x-dev"
    }
}
```

## Adding Routes

Let's add some routes. For the time being we are just going to add matching and handling for routes which are actually found.

We'll start out by using callbacks as handlers but later we are going to progress onto controller classes and methods.

What we need to do is

1. Create a `dispatcher`

2. Dispatch a `URI`, to obtain the `route info`: We dispatch a `URI`, so we will take the `URI` and also the `request` method and pass that into the `dispatcher` in order to obtain the `route info`. There's three pieces of information that we want back if everything has going ok:

    - `Status code`: To say that a route was found
    - `Handler`
    - `Variables`: If we pass in any variables for example, an article ID of 55 then we want to get back a variable ID with the value of 55.

3. Take the `handler`, provided by the `route info`, which is returned to us and then we're going to call it (we'll create a `Response`).

First we create a `dispatcher`. So we must edit `/php-framework-pro/framework/Http/Kernel.php` and add the next code:

```php
use function FastRoute\simpleDispatcher;


class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        $dispatcher = simpleDispatcher(function (RouteCollector $routeCollector) {

            // Using the "$routeCollector" we can start to add routes.
            // Adds a route to the collection. 
            // Parameters:
            // 1. @param string|string[] $httpMethod
            // 2. @param string $route
            // 3. @param mixed $handler

            $routeCollector->addRoute('GET', '/', function () {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = '<h1>Hello World</h1>';

                return new Response($content);
            });
        });

        dd($dispatcher);

        // Dispatch a URI, to obtain the route info


        // Call the handler, provided by the route info, in order to create a Response
    }
}
```

We've added a `dd($dispatcher)` and we get:

```
 FastRoute\Dispatcher\MarkBased {#6 ▼
  #staticRouteMap: array:1 [▼
    "GET" => array:1 [▼
      "/" => Closure() {#10 ▼
        class: "AriadnaJordi\Framework\Http\Kernel"
        this: AriadnaJordi\Framework\Http\Kernel {#2 …}
      }
    ]
  ]
  #variableRouteData: []
}
```

We get a MarkBased Dispatcher and inside of that we have an array which is a static array that is `staticRouteMap` and here we can see something familiar that is the route that we just defined:

```
"GET" => array:1 [
    "/" => Closure()
]
```

The base URI ("/") is pointing towards a closure (closure: is an anonymous function that can access variables imported from outside scope like we're doing here).

Now we're using this `$dispatcher` to get back the route information ie, three pieces of information

1. The status to say that the route was found.
2. The handler.
3. Any variables that we can pass to the handler.

We'll use the method `$dispatcher->dispatch()` which need two parameters, the HTTP method that in our case is `GET` and, we also need the URI. We can get both those pieces of information off of our request. This is something which is dynamic and it will change with each request that comes into our application. So we'll dump our `request` via `dd()` to see where we can get the information that we're looking for.

```php
use function FastRoute\simpleDispatcher;


class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        $dispatcher = simpleDispatcher(function (RouteCollector $routeCollector) {

            // Using the "$routeCollector" we can start to add routes.
            // Adds a route to the collection. 
            // Parameters:
            // 1. @param string|string[] $httpMethod
            // 2. @param string $route
            // 3. @param mixed $handler

            $routeCollector->addRoute('GET', '/', function () {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = '<h1>Hello World</h1>';

                return new Response($content);
            });
        });

        dd($request);

        // Dispatch a URI, to obtain the route info


        // Call the handler, provided by the route info, in order to create a Response
    }
}
```

The variables we want are on the `server` array:

```php
 AriadnaJordi\Framework\Http\Request {#3 ▼
  +getParams: []
  +postParams: []
  +cookies: []
  +files: []
  +server: array:57 [▼
    "HOSTNAME" => "d93ba1e42e7b"
    "PHP_INI_DIR" => "/usr/local/etc/php"
    "SHLVL" => "1"
    "HOME" => "/home/www-data"
    "PHP_LDFLAGS" => "-Wl,-O1 -pie"
    "PHP_CFLAGS" => "-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
    "PHP_VERSION" => "8.2.3"
    "GPG_KEYS" => "39B641343D8C104B2B146DC3F9C39DC0B9698544 E60913E4DF209907D8E30D96659A97C9CF2A795A 1198C0117593497A5EC5C199286AF1F9897469DC"
    "PHP_CPPFLAGS" => "-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
    "PHP_ASC_URL" => "https://www.php.net/distributions/php-8.2.3.tar.xz.asc"
    "COMPOSER_ALLOW_SUPERUSER" => "1"
    "PHP_URL" => "https://www.php.net/distributions/php-8.2.3.tar.xz"
    "PATH" => "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
    "PHPIZE_DEPS" => "autoconf \t\tdpkg-dev dpkg \t\tfile \t\tg++ \t\tgcc \t\tlibc-dev \t\tmake \t\tpkgconf \t\tre2c"
    "PWD" => "/var/www/html"
    "PHP_SHA256" => "b9b566686e351125d67568a33291650eb8dfa26614d205d70d82e6e92613d457"
    "USER" => "www-data"
    "HTTP_ACCEPT_LANGUAGE" => "en-US,en;q=0.9"
    "HTTP_ACCEPT_ENCODING" => "gzip, deflate, br"
    "HTTP_SEC_FETCH_DEST" => "document"
    "HTTP_SEC_FETCH_USER" => "?1"
    "HTTP_SEC_FETCH_MODE" => "navigate"
    "HTTP_SEC_FETCH_SITE" => "none"
    "HTTP_ACCEPT" => "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"
    "HTTP_USER_AGENT" => "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"
    "HTTP_UPGRADE_INSECURE_REQUESTS" => "1"
    "HTTP_SEC_CH_UA_PLATFORM" => ""Linux""
    "HTTP_SEC_CH_UA_MOBILE" => "?0"
    "HTTP_SEC_CH_UA" => ""Chromium";v="118", "Google Chrome";v="118", "Not=A?Brand";v="99""
    "HTTP_CACHE_CONTROL" => "max-age=0"
    "HTTP_CONNECTION" => "keep-alive"
    "HTTP_HOST" => "localhost:8080"
    "REDIRECT_STATUS" => "200"
    "SERVER_NAME" => "localhost"
    "SERVER_PORT" => "80"
    "SERVER_ADDR" => "172.18.0.2"
    "REMOTE_PORT" => "53464"
    "REMOTE_ADDR" => "172.18.0.1"
    "SERVER_SOFTWARE" => "nginx/1.23.2"
    "GATEWAY_INTERFACE" => "CGI/1.1"
    "REQUEST_SCHEME" => "http"
    "SERVER_PROTOCOL" => "HTTP/1.1"
    "DOCUMENT_URI" => "/index.php"
    "REQUEST_URI" => "/"
    "SCRIPT_NAME" => "/index.php"
    "CONTENT_LENGTH" => ""
    "CONTENT_TYPE" => ""
    "REQUEST_METHOD" => "GET"
    "QUERY_STRING" => ""
    "DOCUMENT_ROOT" => "/var/www/html/public"
    "SCRIPT_FILENAME" => "/var/www/html/public/index.php"
    "FCGI_ROLE" => "RESPONDER"
    "PHP_SELF" => "/index.php"
    "REQUEST_TIME_FLOAT" => 1699886721.6427
    "REQUEST_TIME" => 1699886721
    "argv" => []
    "argc" => 0
  ]
}
```

In fact we're looking for the `REQUEST_URI`, `REQUEST_METHOD` variables:

```
"REQUEST_URI" => "/"
"REQUEST_METHOD" => "GET"
```

So we can access this off of the `server` array variable on our `request` object. So we go ahead and do that:

```php
use function FastRoute\simpleDispatcher;


class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        $dispatcher = simpleDispatcher(function (RouteCollector $routeCollector) {

            // Using the "$routeCollector" we can start to add routes.
            // Adds a route to the collection. 
            // Parameters:
            // 1. @param string|string[] $httpMethod
            // 2. @param string $route
            // 3. @param mixed $handler

            $routeCollector->addRoute('GET', '/', function () {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = '<h1>Hello World</h1>';

                return new Response($content);
            });
        });

        // Dispatch a URI, to obtain the route info
        $routeInfo = $dispatcher->dispatch(
            $request->server['REQUEST_METHOD'],
            $request->server['REQUEST_URI']
        );

        dd($routeInfo);

        // Call the handler, provided by the route info, in order to create a Response
    }
}
```

We've added the `dd($routeInfo)` in order to show the result of the `dispatch()` method and to check if everything is going ok. So we get:

```php
 array:3 [▼
  0 => 1
  1 => Closure() {#10 ▼
    class: "AriadnaJordi\Framework\Http\Kernel"
    this: AriadnaJordi\Framework\Http\Kernel {#2 …}
  }
  2 => []
]
```

So we get our `Closure` and our handler `AriadnaJordi\Framework\Http\Kernel`. 
We have a dispatcher interface that holds the three status code here:

```php
<?php
declare(strict_types=1);

namespace FastRoute;

interface Dispatcher
{
    public const NOT_FOUND = 0;
    public const FOUND = 1;
    public const METHOD_NOT_ALLOWED = 2;

    ...
}
```

So we're going to take our `$routeInfo` and we're going to sort of unpack it into variables. The first one is the status `$status`, the second one is the handler `$handler`, and the third one is the variables `$vars`:

```php
[$status, $handler, $vars] = $routeInfo;

dd([$status, $handler, $vars]);
```

We get the unpacked:

```php
 array:3 [▼
  0 => 1
  1 => Closure() {#10 ▼
    class: "AriadnaJordi\Framework\Http\Kernel"
    this: AriadnaJordi\Framework\Http\Kernel {#2 …}
  }
  2 => []
]
```

Now what we want to do is call the `handler` method passing in the variables and then return whatever that returns.

```php
return $handler($vars);
```

The code is:

```php
<?php

namespace AriadnaJordi\Framework\Http;

use FastRoute\Dispatcher;
use FastRoute\RouteCollector;

use function FastRoute\simpleDispatcher;

class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        $dispatcher = simpleDispatcher(function (RouteCollector $routeCollector) {

            // Using the "$routeCollector" we can start to add routes.
            // Adds a route to the collection. 
            // Parameters:
            // 1. @param string|string[] $httpMethod
            // 2. @param string $route
            // 3. @param mixed $handler

            $routeCollector->addRoute('GET', '/', function () {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = '<h1>Hello World</h1>';

                return new Response($content);
            });
        });

        // Dispatch a URI, to obtain the route info.
        // Returns array with one of the following formats:
        //
        //     [self::NOT_FOUND] [self::METHOD_NOT_ALLOWED, ['GET', 'OTHER_ALLOWED_METHODS']] [self::FOUND, $handler, ['varName' => 'value', ...]]
        //
        // Parameters:
        // 
        //     @param string $httpMethod
        //     @param string $uri
        //
        //     @return array{0:int, 1:list<string>|mixed, 2:array<string, string>}
        
        $routeInfo = $dispatcher->dispatch(
            $request->server['REQUEST_METHOD'],
            $request->server['REQUEST_URI']
        );

        [$status, $handler, $vars] = $routeInfo;

        // Call the handler, provided by the route info, in order to create a Response
        return $handler($vars);
    }
}
```

Now we're going to show what's returned:

```php
dd($handler($vars));
```

We get:

```php
 AriadnaJordi\Framework\Http\Response {#4 ▼
  -content: "<h1>Hello World</h1>"
  -status: 200
  -headers: []
}
```

Now we're going to do a route that contains parameters something like:

`localhost/posts/23`

That's the kind of route that we need to match. We can have as many routes as we like. We'll use a handler method on the kernel to centralize all the routes in a single point. We're going to refactor and store all the routes in their own file.

Altought first we're going to write down the next route that contains route parameters. This route parameter named `id` is an integer and we use the regular expression `{id:\d+}` to match it. The regex `{id:\d+}` match one (`\d`) or more (`+`) digits. As we define our routes parameters that means that we can actually pass an argument named `$routeParams` that's an array with our `id` value in it, to our callback function ie `function($routeParams)`:

```php
class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        $dispatcher = simpleDispatcher(function (RouteCollector $routeCollector) {

            // Using the "$routeCollector" we can start to add routes.
            // Adds a route to the collection. 
            // Parameters:
            // 1. @param string|string[] $httpMethod
            // 2. @param string $route
            // 3. @param mixed $handler

            $routeCollector->addRoute('GET', '/', function () {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = '<h1>Hello World</h1>';

                return new Response($content);
            });

            // Another route
            $routeCollector->addRoute('GET', '/posts/{id:\d+}', function ($routeParams) {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = "<h1>This is Post {$routeParams['id']}</h1>";

                return new Response($content);
            });
        });

    .....

    }
}
```

If we try `localhost:8080/posts/23` or `localhost:8080/posts/55`, everything goes as it should be.

Now, if we pass a route that has not match any route we've already registered we must get an error code. For example, if we pass `foo` as a route parameter as in the next url:

`localhos:8080/posts/foo`

We get an undefined array key and we get some errors because we don't actually have handling setup for if we pass the wrong kind of information:

```
Warning: Undefined array key 1 in /var/www/html/framework/Http/Kernel.php on line 64

Warning: Undefined array key 2 in /var/www/html/framework/Http/Kernel.php on line 64

Fatal error: Uncaught Error: Value of type null is not callable in /var/www/html/framework/Http/Kernel.php:69 Stack trace: #0 /var/www/html/public/index.php(29): AriadnaJordi\Framework\Http\Kernel->handle(Object(AriadnaJordi\Framework\Http\Request)) #1 {main} thrown in /var/www/html/framework/Http/Kernel.php on line 69
```


## Retrieving Path Info

We need to make sure that the paths we use for route matching contain only the path without any get parameters so let's create an accessor method on the request class which will do that for us.

We want to make sure that it converts paths like this `/posts?name=Gary` to just the plain path like this `/posts`.

Now we want to create an accessor method for our requested URI because there are instances where it might not come back the way we want it. For example if we go to the url:

`localhost:8080/posts?name=Jordi`

and if we put an `dd()` in the code to see what we get as a variable `server['REQUEST_URI']`.

```PHP
dd($request->server['REQUEST_URI']);
```

When we go to `localhost:8080/posts?name=Jordi` we get:

```
"/posts?name=Jordi"
```

We actually still get the query parameter appended into the end of the URI. Actually for matching our routes and our URIs that is not what we want. We want to actually create an accessor method where we remove the query parameters from the end of that. So we're going to create a method in the `Request` classe called `getPathInfo()`:

```php
class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        $dispatcher = simpleDispatcher(function (RouteCollector $routeCollector) {

            // Using the "$routeCollector" we can start to add routes.
            // Adds a route to the collection. 
            // Parameters:
            // 1. @param string|string[] $httpMethod
            // 2. @param string $route
            // 3. @param mixed $handler

            $routeCollector->addRoute('GET', '/', function () {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = '<h1>Hello World</h1>';

                return new Response($content);
            });

            // Another route
            $routeCollector->addRoute('GET', '/posts/{id:\d+}', function ($routeParams) {

                // We return from this callback handler function, 
                // a new Response with the content:

                $content = "<h1>This is Post {$routeParams['id']}</h1>";

                return new Response($content);
            });
        });

        // Dispatch a URI, to obtain the route info.
        // Returns array with one of the following formats:
        //
        //     [self::NOT_FOUND] [self::METHOD_NOT_ALLOWED, ['GET', 'OTHER_ALLOWED_METHODS']] [self::FOUND, $handler, ['varName' => 'value', ...]]
        //
        // Parameters:
        // 
        //     @param string $httpMethod
        //     @param string $uri
        //
        //     @return array{0:int, 1:list<string>|mixed, 2:array<string, string>}
        
        $routeInfo = $dispatcher->dispatch(
            $request->server['REQUEST_METHOD'],
            $request->getPathInfo()
        );

        [$status, $handler, $vars] = $routeInfo;

        // Call the handler, provided by the route info, in order to create a Response
        // dd($handler($vars));
        
        return $handler($vars);
    }
}
```

Now we'll add the new class method `getPathInfo()` in `/php-framework-pro/framework/Http/Request. php`. To remove the query parameter we'll use the `strtok()` function where the first parameter is the string and the second one is the token (`?`): 

```php
public function getPathInfo(): string 
{
    return strtok($this->server['REQUEST_URI'], '?');
}
```

Using `strtok()` the string passed as the first parameter will be tokenized when any of the characters in the argument are found. In our case that question mark (?) will be found and then that is where the string will actually be split and we'll just return the URI the path being the part that we want.

Now we'll show using `dd($request->getPathInfo())` in the file `php-framework-pro/framework/Http/Kernel.php`

```php
class Kernel
{

    public function handle(Request $request): Response
    {
        // Create a dispatcher
        
        ...
        
        $routeInfo = $dispatcher->dispatch(
            $request->server['REQUEST_METHOD'],
            //$request->server['REQUEST_URI']
            $request->getPathInfo()
        );

        dd($request->getPathInfo());

        ...
    }
}
```

Now back over to the browser and going to `localhost:8080/posts?name=Jordi`

```
 "/posts"
```

Now we'll add a new `Request` method named `getMethod()`:

```php
public function getMethod(): string
{
    return $this->server['REQUEST_METHOD'];
}
```

and also we add it in the logic of the `/php-framework-pro/framework/Http/Kernel.php`

```php
$routeInfo = $dispatcher->dispatch(
            $request->getMethod(),
            $request->getPathInfo()
        );
```

If we go to the browser we'll see everything's working exactly the way that it was. So if we go to `localhost:8080` and `localhost:8080/posts/23` we can see the `Hello World` and `This is Post 23` as it should be.